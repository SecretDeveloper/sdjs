//     sd.js 0.0.1
//     https://github.com/SecretDeveloper/sdjs
//     (c) 2013-2013 Gary Kenneally
//     sdjs may be freely distributed under the MIT license.


(function() {
	
	// get the root object running this instance.
	var root = this;
	
	// 
	var sd = function(obj){
		if(obj instanceof sd) return obj; 
		if(!(this instanceof sd)) return new sd(obj);	
		this._sd = obj;
	};
	
	root.sd = sd;
	
	
	/*	
		If we list all the natural numbers below 10 that are multiples of 3 or 5, we get 3, 5, 6 and 9. 
		The sum of these multiples is 23.
		Find the sum of all the multiples of 3 or 5 below 1000.
	*/
	sd.problem1 = function(){
		return _.reduce(_.range(0,1000), function(memo, number){		
			if( number%3===0 || number%5==0) return memo+number;
			return memo;}
		);		
	};
	
	
	/*
	Each new term in the Fibonacci sequence is generated by adding the previous two terms. By starting with 1 and 2, the first 10 terms will be: 1, 2, 3, 5, 8, 13, 21, 34, 55, 89, ...
	By considering the terms in the Fibonacci sequence whose values do not exceed four million, find the sum of the even-valued terms.
	*/
	sd.problem2 = function(){
		var stack = [];	
		var max = 4000000;
		
		var current = 1;
		var last = 1;		
		
		var result = 0;
		
		while(current < max){			
			var tmp = current;
			current = current+last;
			last = tmp;
			
			if(current % 2 ===0) result += current;
		}
		return result;
	};
	
	sd.findHighestPrimeNumber = function(num){
		if (num < 2) return 1;
		
		var sqrt = parseInt(Math.sqrt(num));
		var max = 0;
				
		for(var i = sqrt; i> 0; i--){
			if(num%i === 0 && sd.findHighestPrimeNumber(i)==1 && i>max){
				max = i;
			}
		}
		return max;		
	};
		
	/*
	The prime factors of 13195 are 5, 7, 13 and 29.
	What is the largest prime factor of the number 600851475143 ?
	*/
	sd.problem3 = function(){
		return sd.findHighestPrimeNumber(600851475143);		
	};
	
	
	sd.reverse = function(str){
		return str.split("").reverse().join("");
	};
	
	sd.isPalindrome = function(num){
		return (''+num) === sd.reverse(''+num);
	};
	/*
	A palindromic number reads the same both ways. 
	The largest palindrome made from the product of two 2-digit numbers is 9009 = 91 × 99.
	Find the largest palindrome made from the product of two 3-digit numbers.
	*/
	sd.problem4 = function(){
		var highest = 0;
		var highestInner = 0;
		
		for(var outer = 999; outer>0; outer--){			
			for(inner = 999; inner>0; inner--){			
				// optimization - Saves us from looping over items that will always provide a smaller palindrome value
				if(outer<highestInner) return highest; 		
				
				var t = inner*outer;
				if(sd.isPalindrome(t) && t>highest) {
					highest = t;
					if(inner>highestInner) highestInner = inner;
				}
			}
		}
		return highest;
	};
	
	/*
	2520 is the smallest number that can be divided by each of the numbers from 1 to 10 without any remainder.
	What is the smallest positive number that is evenly divisible by all of the numbers from 1 to 20?
	*/
	sd.problem5 = function(dividers, lower, upper){
		var divisors = [];
		if(!dividers){
			console.log('no divisors provided');
			divisors = [20,19,18,17,16,15,14,13,12,11];
		}
		else{
			_.map(dividers.sort().reverse(), function(divider){
				var alreadyCovered = false;
				console.log(divider);
				_.each(divisors, function(divisor){
					if(divisor%divider===0) alreadyCovered = true;
				});
				if(!alreadyCovered && divider!==0) divisors.push(divider);  // only add 
			});
			console.log(dividers.sort().reverse());
			console.log(divisors);			
		}					
		
		// this upper/lower bounding stuff is psuedo math at best. no real truth here.
		if(!upper){
			console.log('no upper provided');
			var top = _.reduce(divisors,function(memo,num){ return memo*=num; });
			upper = parseInt(top * 0.001);  // Attempt to set an upper bound
			console.log(upper);
		}
		if(!lower){
			console.log('no lower provided');
			lower = _.reduce(_.range(0,(''+upper).length-1),function(memo){return memo*10},2) //attempt to set a lower bound
			console.log(lower);		
		}
		
		// loop and try to match
		for(var outer=lower; outer<upper; outer++){	
			var match = true;
			for(var x=0; x < divisors.length; x++){
				if(outer%divisors[x] !==0) {
					match = false;
					break;
				}
			}
			if(match) return outer;
		}		
		return 0;
	};
	
	

}).call(this);